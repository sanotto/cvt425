*SRCMBRTXT:Mostrar MB Generico Basado en SQL      
      *COMPILAR CON COMMIT(*NONE)
     H******************************************************************
     H*                                                                *
     H*  APPLICATION CODE : SD V00 01                                  *
     H*                                                                *
     H*  APPLICATION NAME : Sistema Integrado De Bancos                *
     H*                                                                *
     H*  PROGRAM NAME     : BADSSQMB                                   *
     H*                                                                *
     H*  PROGRAM TITLE    : Mostrador Generico de MB Basado en SQL     *
     H*                                                                *
     H*  DATE GENERATED   : 17/04/12                                   *
     H*                                                                *
     H*  AUTHOR           : PR00525                                    *
     H*                                                                *
     H*  IPG LEVEL        : QUIEN NECESITA IPG??????? JEJEJE           *
     H*                                                                *
     H*  PTF LEVEL        : PÑGÑV20114                                 *
     H*                                                                *
     H******************************************************************
     H*  MODIFICATION CONTROL                                          *
     H*  ~~~~~~~~~~~~~~~~~~~~                                          *
     H*  Date      Programmer  Description                  Ref. No.   *
     H*  ~~~~      ~~~~~~~~~~  ~~~~~~~~~~~                  ~~~~~~~~   *
     H******************************************************************
     H DFTACTGRP(*NO) ACTGRP(*NEW)
     H BNDDIR('QC2LE')

     Fbadsmbsq  CF   E             WORKSTN SFILE(D01:NRR)
     FSGSYSV    IF   E             DISK
     F@CPIUSD   IF A E             DISK    USROPN
     ***************************************************************************
     ** PROTOTYPES
     ***************************************************************************
     D*-------------------------------------------------------------------------
     D*>DATASTRUCTURE : SYSERR
     D*>DESCRIPTION   : Data structure to receive error generated by OPM APIS
     D*>USE           : Retrieve OPM API Error codes
     D*>RELATEDFUNCT  : sysSndPgmMsg
     D*-------------------------------------------------------------------------
      /IF NOT DEFINED(SYSERR_DEFINED)
      /DEFINE SYSERR_DEFINED
     D SYSERR          DS
     D  dsECBytesP             1      4I 0 INZ(256)
     D  dsECBytesA             5      8I 0 INZ(0)
     D  dsECMsgID              9     15
     D  dsECReserv            16     16
     D  dsECMsgDta            17    256
      /ENDIF

     D*------------------------------------------------------------------------
     D*>DESCRIPTION   : Sends a program message
     D*>RETURNS       : A string containing the message key generated by the Sy
     D*>PARAMETER     : A string containig MSGI
     D*>PARAMETER     : A string containig MSGF LIB (OPT)
     D*>PARAMETER     : A string containig User data (OPT)
     D*>USAGE         : Eval      rc=sysSndPgmMsg('CPF9801':'QCPFMSG   *LIBL
     D*------------------------------------------------------------------------
     D  sysSndPgmMsg   PR             4A
     D   msgID                        7A   CONST
     D   msgF                        20A   CONST OPTIONS(*NOPASS)
     D   msgDta                     256A   CONST OPTIONS(*NOPASS)
     D   msgType                     10A   CONST OPTIONS(*NOPASS)
     D*------------------------------------------------------------------------

      *********************************************************
      * Definitions needed to make IFS API calls.  Note that
      * these should really be in a separate /copy file!
      *********************************************************
     D O_WRONLY        C                   2
     D SEEK_SET        C                   0
     D O_RDWR          C                   4
     D O_CREAT         C                   8
     D O_TRUNC         C                   64
     D O_CODEPAGE      C                   8388608

     D Sndpm           PR                  ExtPgm('QMHSNDPM')
     D   MessageID                    7A   Const
     D   QualMsgF                    20A   Const
     D   MsgData                    256A   Const
     D   MsgDtaLen                   10I 0 Const
     D   MsgType                     10A   Const
     D   CallStkEnt                  10A   Const
     D   CallStkCnt                  10I 0 Const
     D   MessageKey                   4A
     D   ErrorCode                32766A   options(*varsize)
     ***************************************************************************
     ** PROGRAM START
     ***************************************************************************
     D*----------------------------------------------------------------*
     D                 DS
     D  @ZFNKY                 1     24
     D  @FN                    1     99
     D                                     DIM(99)
     D*----------------------------------------------------------------*
     D               ESDS                  EXTNAME(@PSDS)
     D*----------------------------------------------------------------*
     D LDA           E DS                  EXTNAME(LDA)
     I*----------------------------------------------------------------*
     I*----------------------------------------------------------------*
     I*----------------------------------------------------------------*
     D*------------------
     D*Field Directory Table
     D*------------------

     D*------------------
     D*Number Convertion Data Structure
     D*------------------
     D CvtDs           DS

     D SQL_NUM         C                   CONST(300)

     D QryStr          S           8192A
     D i               S             10I 0
     D j               S             10I 0
     D k               S             10I 0
     D l               S             10I 0
     D SelR            S             10I 0
     D RowSze          S             10I 0
     D FldByt          S             10I 0
     D FldLen          S             10I 0
     D FldSca          S             10I 0
     D OffSet          S             10I 0
     D RcdLen          S             10I 0
     D FilHnd          S             10I 0
     D HdrBuf          S           8192A   INZ(*ALLX'00')
     D HdrLon          S             10I 0
     D CurDig          S              2S 0
     d RecPtr          S               *
     D RowPtr          S               *
     D IndPtr          S               *
     D RunPtr          S               *
     D StrAdr          S               *
     D RunPtrDS        DS                  BASED(RunPtr)
     D  RunPtrChr              1      1A
     D  RunPtrByt              1      1S 0
     D RunPt2          S               *
     D RunPt2DS        DS                  BASED(RunPt2)
     D  RunPt2Chr              1      1A
     D  RunPt2Byt              1      1S 0
     D RunInd          S               *
     D RowCtr          S             10I 0
     D FldBeg          S             10I 0 DIM(300)
     D FldTpe          S             10I 0 DIM(300)
     D FldCOH          S            255A   DIM(300)
     D FldEnd          S             10I 0 DIM(300)
     D FldLar          S             10I 0 DIM(300)
     D NegFlg          S              1A
     D CV2DIN          S              1A
     D COHELI          S           4096A
     D Linea           S           4096A   DIM(30)

     D*------------------
     D*Cabecera de Archivo Dbase III
     D*------------------
     D DBFHdr          DS
     D  HdrStr                 1     32
     D  VerNum                 1      1A   INZ(X'03')
     D  LstUpd                 2      4A   INZ(X'010101')
     D  RecNum                 5      8A   INZ(X'00000000')
     D  HdrLen                 9     10A
     D  RecLen                11     12A
     D  ResSp1                13     14A   INZ(X'0000')
     D  IncTrn                15     15A   INZ(X'00')
     D  EncFlg                16     16A   INZ(X'00')
     D  FreThd                17     20A   INZ(X'00000000')
     D  ResSp2                21     28A   INZ(X'0000000000000000')
     D  MDXFlg                29     29A   INZ(X'00')
     D  LngDrv                30     30A   INZ(X'01')
     D  ResSp3                31     32A   INZ(X'0000')

     D*------------------
     D*Field Directory Table
     D*------------------
     D DBFFld          DS
     D  FldDsc                 1     32A
     D  FldNam                 1     11A
     D  FldOff                13     16A
     D  FldLon                17     17A
     D  FldDec                18     18A
     D  ResSc1                19     20A   INZ(x'0000')
     D  WarIde                21     21A   INZ(x'00')
     D  ResSc2                22     23A   INZ(x'0000')
     D  FldFlg                24     24A   INZ(x'00')
     D  ResSc3                25     31A   INZ(x'00000000000000')
     D  FldIdx                32     32A   INZ(X'00')

     C                   ExSr      FiltrosCPI
     C                   ExSr      OpenCursor
     C                   EXSR      BuildSQLBuf
     C                   EXSR      RecMetaData
     C                   EXSR      BuildRecBuffer
     c                   ExSr      BuildColHead
     c                   ExSr      DspResultSet
     c                   ExSr      CloseCursor
     C                   DEALLOC                 RowPtr
     C                   DEALLOC                 RecPtr
     c                   ExSr      EndPgm
     C*
     C*---------------------------------------------------------------------
     c     DspResultSet  BegSr
     C*---------------------------------------------------------------------
     C*
     c                   Z-ADD     10            MaxReng           5 0
     c                   Z-ADD     1             FromCol           5 0
     C*
     c                   ExSr      NextPage
     c                   ExSr      ShowSubfile
     C                   DoW       *IN03 = *OFF And *IN12 = *Off
     c                   Select
     c                   When      *In46=*On and SQLCOD = *Zero
     c                   ExSr      NextPage
     c                   When      *In46=*On
     c                   When      *In45=*On
     c                   ExSr      PrevPage
     c                   When      *In19=*On
     c                   ExSr      MovIzq
     c                   When      *In20=*On
     c                   ExSr      MovDer
     c                   Other
     c                   If        @ZFNKY <> *ALL'0'
     c                   Leave
     c                   EndIf
     c                   ExSr      CheckSelect
     c                   Leave
     C                   EndSl
     c                   ExSr      ShowSubfile
     C                   EndDo
     C*
     c                   ExSr      GrabarCPI
     C*
     C                   EndSr
     c*-------------------------------------------------------------------------
     c     EndPgm        BegSr
     c*-------------------------------------------------------------------------
     C                   Seton                                        LR
     c                   Return
     C*
     c                   EndSr

     c*-------------------------------------------------------------------------
     c     CheckSelect   BegSr
     c*-------------------------------------------------------------------------
     c                   For       SelR=1 to MaxReng
     c     SelR          Chain     D01                                2626
     c                   If        Opc <> *BLANKS and *IN26 = *Off
     C                   ExSr      SaveSelect
     c                   Leave
     C                   EndIf
     c                   EndFor
     C                   EndSr

     c*-------------------------------------------------------------------------
     c     GrabarCPI     BegSr
     c*-------------------------------------------------------------------------
     C*
     c/Exec sql
     c+ UPDATE @CPISYS SET
     c+ @ZFNKY=:@ZFNKY ,
     c+ @ZOPSL=:OPC
     c+ WHERE
     c+ @ZJOBN=:@PJOBN
     c/End-Exec
     C                   EndSr

     c*-------------------------------------------------------------------------
     c     SaveSelect    BegSr
     c*-------------------------------------------------------------------------
     C*
     c* ... Salvar OPC en  @CPIOPT
     c/Exec SQL
     c+ update @cpiusd set @CIOPT=:opc where @ZJOBN=:@PJOBN
     c/End-Exec
     C*
     C                   FOR       i=1 TO SQLD
     C                   If        %SubSt(FldCOH(i):1:2)='@C' or
     C                             %SubSt(FldCOH(i):1:2)='@c'
     c                   Move      FldBeg(i)     inicio            8 0
     c                   Add       1             inicio
     c                   Z-Add     *zero         Largo             5 0
     c                   Eval      Largo = FldEnd(i)-FldBeg(i)
     c                   Move      *Blanks       Value          4096
     c                   Select
     c*                  //Texto
     C                   When      FldTpe(i)=452 Or FldTpe(i)=453
     c                   Eval      Value=''''+
     c                             %Trim(%SubSt(Linea(SelR):Inicio:Largo))+
     c                             ''''
     c*                  //Numerico
     C                   When      FldTpe(i)=484 Or FldTpe(i)=485 Or
     C                             FldTpe(i)=488 Or FldTpe(i)=489
     c                   Eval      Value=
     c                             %Trim(%SubSt(Linea(SelR):Inicio:Largo))
     c
     c                   EndSl
     C                   EVAL      Value=%XLATE(X'00':x'40':Value)
     c                   Move      *Blanks       UpdStr          512
     c                   Eval      UpdStr='UPDATE @CPIUSD SET '+
     C                             %Trim(FldCOH(i))+' = ' +
     C                             %Trim(Value) +
     c                             ' WHERE @ZJOBN='+%EditW(@PJOBN:'      ')
     C/Exec SQL
     C+ PREPARE S2 FROM :UpdStr
     C/End-Exec
     C                   If        SQLCOD <> *ZERO
     c                   EndIf
     c/Exec SQL
     C+ EXECUTE S2
     C/End-Exec
     c                   EndIf
     C                   ENDFOR
     c
     C*
     C                   EndSr

     c*-------------------------------------------------------------------------
     c     MovDer        BegSr
     c*-------------------------------------------------------------------------
     c                   Add       1             FromCol
     C*
     c                   If        FromCol >  LastVisCol
     C                   Sub       1             FromCol
     C                   EndIf
     C*
     c                   EndSr
     c*-------------------------------------------------------------------------
     c     MovIzq        BegSr
     c*-------------------------------------------------------------------------
     c                   Sub       1             FromCol
     c                   If        FromCol <= *ZERO
     C                   Z-Add     1             FromCol
     C                   EndIf
     C*
     c                   EndSr
     C*-------------------------------------------------------------------------
     c     OpenCursor    BegSr
     C*-------------------------------------------------------------------------
     C/Exec Sql
     C+ INCLUDE SQLDA
     C/End-Exec
     C/Exec Sql
     C+ PREPARE S1 FROM :QryStr
     C/End-Exec
     C/Exec Sql
     C+ DECLARE C1 SCROLL CURSOR FOR S1
     C/End-Exec
     C                   EXSR      ChkSQLCode
     C/Exec Sql
     C+ OPEN C1
     C/End-Exec
     C                   EXSR      ChkSQLCode
     C/Exec Sql
     C+ ALLOCATE DESCRIPTOR 'SQLDA' WITH MAX 300
     C/End-Exec

     C/Exec Sql
     C+ DESCRIBE S1 INTO :SQLDA
     C/End-Exec
     C                   IF        SQLN < SQLD
     C                   Z-ADD     SQLD          MAXROWS          15 0
     C/Exec Sql
     C+ ALLOCATE DESCRIPTOR 'SQLDA' WITH MAX :MAXROWS
     C/End-Exec
     C/Exec Sql
     C+ DESCRIBE S1 INTO :SQLDA
     C/End-Exec
     C                   ENDIF
     C                   EXSR      ChkSQLCode
     C*
     C                   EndSr

     c*-------------------------------------------------------------------------
     c     FiltrosCPI    BegSr
     c*-------------------------------------------------------------------------
     c*
     c                   Move      *Blank        Char              1
     c                   Move      *Blanks       CPIFLD            6
     C*                  EVAL      QryStr=*BLANKS
     c                   Eval      J=1
     c                   Eval      K=1
     c                   For       i= i To %Len(%Trim(parstr))
     c                   Eval      Char=%subst(parstr:k:1)
     c*                  If        Char=':' and (
     c*                            %subst(parstr:k+6:1) <> *Blank or
     c*                            %subst(parstr:k+6:1) <> '''' or
     c*                            %subst(parstr:k+1:2) <> '@C'   or
     c*                            %subst(parstr:k+1:2) <> '@c'   )
     C*                  callp     sysSndPgmMsg('CPF9897':'QCPFMSG   *LIBL':
     C*                                  'Parametro de sust. No valido':
     C*                                         '*ESCAPE'   )
     c*                  ExSr      EndPgm
     c*                  EndIf
     c                   If        Char=':'
     c                   Eval      CPIFLD= %subst(parstr:k+1:6)
     c                   ExSr      GetCPIValue
     c                   EndIf
     C                   EVAL      %Subst(QryStr:j:1)=Char
     c                   Add       1             j
     c                   Add       1             K
     c                   EndFor
     c*
     c                   EndSr

     c*-------------------------------------------------------------------------
     c     GetCPIValue   BegSr
     c*-------------------------------------------------------------------------
     c*
     c                   Move      *Blanks       FLDVAL          255
     c                   Move      *Blanks       FKEY              2
     c                   Z-Add     *Zero         VALLEN            3 0
     c                   Call      'BAGETCPI'
     c                   Parm                    CPIFLD
     C                   Parm                    FLDVAL
     c                   Parm                    FKEY
     c*
     c                   Eval      VALLEN=%Len(%trim(FldVal))
     c                   For       L = 1 To VALLEN
     c                   Eval      Char=%subst(FldVal:L:1)
     C                   EVAL      %Subst(QryStr:j:1)=Char
     c                   Add       1             j
     C                   EndFor
     c                   Add       6             k
     c                   Move      *Blank        Char
     c*
     c                   EndSr

     c*-------------------------------------------------------------------------
     c     CloseCursor   BegSr
     c*-------------------------------------------------------------------------
     c*
     C/Exec Sql
     C+ CLOSE C1
     C/End-Exec
     c*
     c                   EndSr

     c*-------------------------------------------------------------------------
     c     *INZSR        BegSr
     c*-------------------------------------------------------------------------
     C*
     c     *entry        Plist
     c                   Parm                    PGMNME           10
     c                   Parm                    PGMTIT           30
     c                   Parm                    HEDLI1           78
     c                   Parm                    HEDLI2           78
     c                   Parm                    HEDLI3           78
     c                   Parm                    FUNKY1           64
     c                   Parm                    parstr         4096
     c                   If        HEDLI1 = *BLANKS AND
     c                             HEDLI2 = *BLANKS AND
     c                             HEDLI3 = *BLANKS
     c                   Eval      HEDLI2='Por favor, seleccione una opción'
     c                   Eval      HEDLI3=' 1=Seleccionar'
     C                   EndIf
     C* setup number of sqlda entries and length of the sqlda
     C                   EVAL       SQLD = 300
     C                   EVAL       SQLN = 300
     C                   EVAL       SQLDABC =SQLN*%LEN(SQLVAR)+16
     C*
     c     1             Chain     RESGSYSV                           25
     c*
     C                   Open      @CPIUSD
     c     @PJOBN        Chain     @CPIUSRR                           99
     c                   If        *in99 = *On
     c                   Z-Add     @PJOBN        @ZJOBN
     c                   Write     @CPIUSRR
     c                   EndIf
     C                   Close     @CPIUSD
     c*
     c                   EndSr

     c*-------------------------------------------------------------------------
     c     ShowSubfile   BegSr
     c*-------------------------------------------------------------------------
     C*
     c                   ExSr      BldDspCOH
     C                   SETOFF                                       303126
     C                   Z-ADD     0             NRR               2 0
     C                   WRITE     C01
     C                   For       k   = 1 To MaxReng
     c                   Move      *Blanks       SFLLIN
     c                   If        Linea(k  ) = *Blanks
     C                   Leave
     c                   EndIf
     c                   ExSr      BldSflLine
     c                   Add       1             Nrr
     C                   WRITE     D01                                    26
     C                   EndFor
     c                   Setoff                                       353637
     C     NRR           COMP      *ZERO                              30
     C     SQLCOD        COMP      *ZERO                              34
     C                   If        FromCol=1 and *In19 = '1'
     c                   SetOn                                        35
     c                   EndIf
     C                   If        FromCol=LastVisCol and *In20 = '1'
     c                   SetOn                                        36
     c                   EndIf
     C                   SETON                                        31
     C                   WRITE     P01
     C                   EXFMT     C01
     c                   MoveA     *in           @FN
     c
     C*
     C                   EndSr

     c*---------------------------------------------------------------------
     c     BldDspCOH     BegSr
     c*---------------------------------------------------------------------
     c                   Z-Add     70            linlen            4 0
     c                   Z-Add     *zero         colbeg            4 0
     c                   Eval      colbeg = FldBeg(FromCol)+1
     c                   If        colbeg +70 > 4096
     c                   Eval      linlen = 4096 - colbeg
     c                   EndIf
     c                   Move      COHELI        WWCOHE         4096
     C* ... Aca hay un truco, ColDelta se pone a cero cuando se encuentra
     c*     El primer @c => si hay parametros quedara + 1 si no hay
     c*     parametros quedara (+1 -1) o sea cero
     c                   Eval      Inicio=FldBeg(LastVisCol+ 1 - ColDelta)
     c                   Eval      Largo =4096 -Inicio
     c                   Eval      %Subst(WWCOHE:Inicio:Largo)=*Blanks
     C                   Eval      COLHDG=%Subst(WWCOHE:colbeg:linlen)
     C*
     C                   EndSr

     c*---------------------------------------------------------------------
     c     BldSflLine    BegSr
     c*---------------------------------------------------------------------
     c                   Move      Linea(k)      WWCOHE         4096
     c                   Eval      Inicio=FldBeg(LastVisCol+1 -ColDelta)
     c                   Eval      Largo =4096 -Inicio
     c                   Eval      %Subst(WWCOHE:Inicio:Largo)=*Blanks
     C                   Eval      SFLLIN=%Subst(WWCOHE:colbeg:linlen)
     C*
     C                   EndSr

     c*-------------------------------------------------------------------------
     C*
     c*-------------------------------------------------------------------------
     c     NextPage      BegSr
     c*-------------------------------------------------------------------------
     C*
     c                   Z-ADD     1             Renglones         5 0
     c                   Z-ADD     *ZERO         RowCtr
     c                   Clear                   Linea
     C/Exec Sql
     C+ FETCH NEXT FROM C1 USING DESCRIPTOR :SQLDA
     C/End-Exec
     C                   DOW       SQLCOD = *ZERO
     c                   Add       1             Renglones         5 0
     C                   EXSR      PRCROW
     c                   If        Renglones > MaxReng
     c                   Leave
     C                   EndIf
     C/Exec Sql
     C+ FETCH NEXT FROM C1 USING DESCRIPTOR :SQLDA
     C/End-Exec
     C                   ENDDO
     c*
     c                   EndSr

     c*-------------------------------------------------------------------------
     c     PrevPage      BegSr
     c*-------------------------------------------------------------------------
     C*
     c                   Clear                   Linea
     c                   For       I = 1 To ((MaxReng * 2))
     C/Exec Sql
     C+ FETCH PRIOR FROM C1 USING DESCRIPTOR :SQLDA
     C/End-Exec
     C                   EndFor
     c*
     c                   ExSr      NextPage
     c*
     c                   EndSr

     c*---------------------------------------------------------------------
     C     RecMetaData   BEGSR
     c*---------------------------------------------------------------------
     C                   Z-Add     *ZERO         LastVisCol       15 0
     C                   Z-Add     1             ColDelta          1 0
     C                   EVAL      RcdLen=1
     C                   EVAL      OffSet=0
     C                   FOR       i=1 TO SQLD
     C                   MOVE      SQL_VAR(i)    SQLVAR
     C                   EXSR      DetFldLen
     C                   EVAL      RcdLen=RcdLen+FldLen+2
     C                   EVAL      FldBeg(i)=OffSet
     C                   EVAL      OffSet=OffSet+FldLen+2
     C                   EVAL      FldEnd(i)=OffSet
     C                   EVAL      FldCOH(i)=SQLNAME
     C                   EVAL      FldLar(i)=FldLen
     C                   EVAL      FldTpe(i)=SQLTYPE
     c                   If        %Subst(SQLNAME:1:2)='@C' or
     c                             %Subst(SQLNAME:1:2)='@c'
     c                   Z-Add     *ZERO         ColDelta
     C                   EndIf
     c                   Eval      LastVisCol=LastVisCol + ColDelta
     C                   ENDFOR
     C*
     C                   ENDSR

     C*-------------------------------------------------------------------------
     C     ChkSQLCode    BEGSR
     C*-------------------------------------------------------------------------
     C                   IF        SQLCOD <> *ZERO
     C                   DEALLOC                 RowPtr
     C                   DEALLOC                 RecPtr
     C                   MOVE      SQLCOD        CDEAU1            4 0
     C                   MULT      -1            CDEAU1
     C                   MOVE      CDEAU1        CDEAU2
     C                   MOVEL(P)  'SQL'         CDEAU2            7
     C                   callp     sysSndPgmMsg('CPF9897':'QCPFMSG   *LIBL':
     C                                          'Error SQL:'+%CHAR(SQLCOD):
     C                                          '*INFO  '   )
     C                   callp     sysSndPgmMsg('CPF9897':'QCPFMSG   *LIBL':
     C                                          'SQL:'+QryStr:
     C                                          '*INFO  '   )
     C                   callp     sysSndPgmMsg(CDEAU2   :'QSQLMSG   *LIBL':
     C                                          'Error'                   :
     C                                          '*INFO  '   )
     C                   Seton                                        LR
     C                   Return
     C                   ENDIF
     C                   ENDSR

     C*------------------
     C* PROCES ROW
     C*------------------
     C     PRCROW        BEGSR
     C                   FOR       i=1 TO SQLD
     C                   MOVE      SQL_VAR(i)    SQLVAR
     C                   EXSR      DetFldLen
     C                   SELECT
     C                   WHEN      SQLTYPE=452 OR SQLTYPE=453
     C                   EXSR      TXTFLD
     C                   WHEN      SQLTYPE=484 OR SQLTYPE=485
     C                   EXSR      PAKFLD
     C                   WHEN      SQLTYPE=488 OR SQLTYPE=489
     C                   EXSR      ZONFLD
     C                   ENDSL
     C                   ENDFOR
     C                   EVAL      RowCtr=RowCtr+1
     C*                  EVAL      RunPt2=RecPtr+FldBeg(i)
     C                   EVAL      RunPt2=RecPtr
     c                   For       I=1 TO RcdLen + 1
     C                   EVAL      %SUBST(Linea(RowCtr):i:1)=RunPt2Chr
     c                   Eval      RunPt2=RunPt2+1
     C                   EndFor
     C                   ENDSR
     C*------------------
     C* Build Column Headers
     C*------------------
     C     BuildColHead  BEGSR
     C                   FOR       i=1 TO SQLD
     c                   Move      FldBeg(i)     inicio            8 0
     c                   Add       1             inicio
     c                   Z-Add     *zero         Largo             5 0
     c                   Eval      Largo = FldEnd(i)-FldBeg(i)
     c                   If        (Inicio-1)> 1
     c                   Eval      %Subst(COHELI:Inicio-1:1)=x'21'
     c                   EndIf
     c                   Eval      %Subst(COHELI:Inicio:Largo )=FldCOH(i)
     c                   Eval      %Subst(COHELI:Inicio+Largo-2:1 )=x'20'
     C                   ENDFOR
     C                   ENDSR

     C*------------------
     C* DATE FIELD DATA COPY
     C*------------------
     C     DTEFLD        BEGSR
     C                   EVAL      RunPtr=SQLDATA
     C                   EVAL      RunPt2=RecPtr+FldBeg(i)-1
     C                   MOVE      *BLANKS       CHAR              1
     C*                  FOR       J=1 TO fldlen
     c* (A)AAAMMDD
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR=%CHAR(%DIV(CV2DOU:16))
     C                   EVAL      RunPt2Chr=CHAR
     C                   EVAL      RunPt2=RunPt2+1
     c* A(A)AAMMDD
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR=%CHAR(%REM(CV2DOU:16))
     C                   EVAL      RunPt2Chr=CHAR
     C                   EVAL      RunPt2=RunPt2+1
     C* ... Avanzo en SQLDATA
     C                   EVAL      RunPtr=RunPtr+1
     C*
     c* AA(A)AMMDD
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR     =%CHAR(%DIV(CV2DOU:16))
     C                   EVAL      RunPt2Chr= CHAR
     C                   EVAL      RunPt2=RunPt2+1
     c* AAA(A)MMDD
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR     =%CHAR(%REM(CV2DOU:16))
     C                   EVAL      RunPt2Chr= CHAR
     C                   EVAL      RunPt2=RunPt2+1
     C* ... Avanzo en SQLDATA
     C                   EVAL      RunPtr=RunPtr+1
     c* AAAA(M)MDD
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR     =%CHAR(%DIV(CV2DOU:16))
     C                   EVAL      RunPt2Chr= CHAR
     C                   EVAL      RunPt2=RunPt2+1
     c* AAAAM(M)DD
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR     =%CHAR(%REM(CV2DOU:16))
     C                   EVAL      RunPt2Chr= CHAR
     C                   EVAL      RunPt2=RunPt2+1
     C* ... Avanzo en SQLDATA
     C                   EVAL      RunPtr=RunPtr+1
     c* AAAAMM(D)D
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR     =%CHAR(%DIV(CV2DOU:16))
     C                   EVAL      RunPt2Chr= CHAR
     C                   EVAL      RunPt2=RunPt2+1
     c* AAAAMMD(D)
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR     =%CHAR(%REM(CV2DOU:16))
     C                   EVAL      RunPt2Chr= CHAR
     C                   EVAL      RunPt2=RunPt2+1
     C* ... Avanzo en SQLDATA
     C                   EVAL      RunPtr=RunPtr+1
     c* AAAAMMD(D)
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CHAR     =%CHAR(%DIV(CV2DOU:16))
     C                   EVAL      RunPt2Chr= CHAR
     C                   EVAL      RunPt2=RunPt2+1
     C* ... Avanzo en SQLDATA
     C                   EVAL      RunPtr=RunPtr+1
     c*
     C                   ENDSR

     C*------------------
     C* PACKED FIELD DATA COPY
     C*------------------
     C     PAKFLD        BEGSR
     C                   EXSR      CLRFLD
     C                   EVAL      RunPtr=SQLDATA+FldByt
     C                   EVAL      RunPt2=RecPtr+FldBeg(i)+FldLen
     C                   EVAL      NegFlg=*OFF
     C                   EVAL      k=0
     C                   FOR       j=1 TO FldByt
     C                   EVAL      RunPtr=RunPtr-1
     C                   EVAL      CV2DIN=RunPtrChr
     C                   EXSR      CV2DEC
     C                   EVAL      CurDig= %REM(CV2DOU:16)
     C                   EXSR      PRCDIG
     C                   EVAL      CurDig= %DIV(CV2DOU:16)
     C                   EXSR      PRCDIG
     C                   ENDFOR
     C                   EVAL      RunPt2=RecPtr+FldBeg(i)
     C                   FOR       j=1 TO FldLen
     C                   IF        RunPt2Chr ='0' OR RunPt2Chr =*BLANK
     C                   EVAL      RunPt2Chr=*BLANK
     C                   EVAL      RunPt2=RunPt2+1
     C                   ELSE
     C                   IF        NegFlg = *ON
     C                   EVAL      RunPt2=RunPt2-1
     C                   EVAL      RunPt2Chr='-'
     C                   EVAL      NegFlg = *OFF
     C                   ENDIF
     C                   LEAVE
     C                   ENDIF
     C                   ENDFOR
     C                   ENDSR

     C     PRCDIG        BEGSR
     C                   IF        CurDig = 13  OR CurDig=15
     C                   IF        CurDig = 13
     C                   EVAL      NegFlg=*ON
     C                   ENDIF
     C                   ELSE
     C                   EVAL      RunPt2=RunPt2-1
     C                   EVAL      k=k+1
     C                   EVAL      RunPt2Chr=%CHAR(CurDig)
     C                   IF        K=FldSca
     C                   EVAL      RunPt2=RunPt2-1
     C                   EVAL      RunPt2Chr='.'
     C                   ENDIF
     C                   ENDIF
     C                   ENDSR
     C*---------------------
     C*
     C*---------------------
     C     CV2DEC        BEGSR
     C                   Z-ADD     *ZERO         CV2DOU            3 0
     C                   TESTB     '0'           CV2DIN                   30
     C                   TESTB     '1'           CV2DIN                   31
     C                   TESTB     '2'           CV2DIN                   32
     C                   TESTB     '3'           CV2DIN                   33
     C                   TESTB     '4'           CV2DIN                   34
     C                   TESTB     '5'           CV2DIN                   35
     C                   TESTB     '6'           CV2DIN                   36
     C                   TESTB     '7'           CV2DIN                   37
     C   30              ADD       128           CV2DOU
     C   31              ADD       64            CV2DOU
     C   32              ADD       32            CV2DOU
     C   33              ADD       16            CV2DOU
     C   34              ADD       8             CV2DOU
     C   35              ADD       4             CV2DOU
     C   36              ADD       2             CV2DOU
     C   37              ADD       1             CV2DOU
     C                   ENDSR

     C*------------------
     C* Clear Field
     C*------------------
     C     CLRFLD        BEGSR
     C                   EVAL      RunPt2=RecPtr+FldBeg(i)
     C                   FOR       j=1 TO FldLen
     C                   EVAL      RunPt2Chr=' '
     C                   EVAL      RunPt2=RunPt2+1
     C                   ENDFOR
     C                   ENDSR

     C*------------------
     C* ZONED FIELD DATA COPY
     C*------------------
     C     ZONFLD        BEGSR
     C                   EXSR      CLRFLD
     C                   EVAL      RunPtr=SQLDATA+FldByt
     C                   EVAL      RunPt2=RecPtr+FldBeg(i)+FldLen
     C                   EVAL      NegFlg=*OFF
     C                   FOR       j=1 TO FldByt
     C                   EVAL      RunPtr=RunPtr-1
     C                   EVAL      RunPt2=RunPt2-1
     C                   IF        RunPtrChr >='J' and RunPtrChr <='R'
     C                   EVAL      NegFlg=*ON
     C                   EVAL      RunPtrChr=%CHAR(%ABS(RunPtrByt))
     C                   ENDIF
     C                   EVAL      RunPt2Chr=RunPtrChr
     C                   IF        j=FldSca
     C                   EVAL      RunPt2=RunPt2-1
     C                   EVAL      RunPt2Chr='.'
     C                   ENDIF
     C                   ENDFOR
     C                   EVAL      RunPt2=RecPtr+1+FldBeg(i)
     C                   FOR       j=1 TO FldLen
     C                   IF        RunPt2Chr ='0' OR RunPt2Chr =*BLANK
     C                   EVAL      RunPt2Chr=*BLANK
     C                   EVAL      RunPt2=RunPt2+1
     C                   ELSE
     C                   IF        NegFlg = *ON
     C                   EVAL      RunPt2=RunPt2-1
     C                   EVAL      RunPt2Chr='-'
     C                   EVAL      NegFlg = *OFF
     C                   ENDIF
     C                   LEAVE
     C                   ENDIF
     C                   ENDFOR
     C                   ENDSR

     C*------------------
     C* TEXT FIELD DATA COPY
     C*------------------
     C     TXTFLD        BEGSR
     C                   EVAL      RunPtr=SQLDATA
     C                   EVAL      RunPt2=RecPtr+FldBeg(i)
     C                   FOR       J=1 TO SQLLEN
     C                   EVAL      RunPt2Chr=RunPtrChr
     C                   EVAL      RunPtr=RunPtr+1
     C                   EVAL      RunPt2=RunPt2+1
     C                   ENDFOR
     C                   ENDSR

     C*-------------------------------------------------------------------------
     C     BuildSQLBuf   BegSr
     C*-------------------------------------------------------------------------
     C*                  'Calcular Memoria necesaria para contener una fila
     C                   ExSr      CalcRecBufSze
     C*                  'Pedir Memoria para el registro
     C                   Monitor
     C                   Eval      RowPtr=%ALLOC(RowSze)
     C                   On-Error  425:426
     C                   EndMon
     C                   Monitor
     C*                  'Pedir Memoria para los null ind,2 bytes por columna
     C                   Eval      IndPtr=%ALLOC(SQLD * 2)
     C                   On-Error  425:426
     C                   EndMon
     C*                  'Asignar Punteros al area SQL para que deje los datos
     c*                  'Cuando se haga un Fetch
     C                   ExSr      AsigPunteros
     C*
     C                   EndSr

     c*-------------------------------------------------------------------------
     C     CalcRecBufSze BegSr
     c*-------------------------------------------------------------------------
     C                   EVAL      RowSze=0
     C                   FOR       i=1 TO SQLD
     C                   MOVE      SQL_VAR(I)    SQLVAR
     C                   EXSR      DetFldLen
     C                   EVAL      RowSze=RowSze+FldByt
     C                   ENDFOR
     C                   ENDSR

     C*------------------
     C* BUILD .DBF RECORD
     C*------------------
     C     BuildRecBufferBEGSR
     C                   MONITOR
     C                   EVAL      RecPtr=%ALLOC(RcdLen)
     C                   ON-ERROR  425:426
     C                   ENDMON
     C                   ENDSR


     C*------------------
     C* ASIGN POINTERS
     C*------------------
     C     AsigPunteros  BEGSR
     C                   EVAL      RunPtr=RowPtr
     C                   EVAL      RunInd=IndPtr
     C                   FOR       i=1 TO SQLD
     C                   MOVE      SQL_VAR(i)    SQLVAR
     C                   EVAL      SQLDATA=RunPtr
     C                   EVAL      SQLIND=RunInd
     C                   MOVE      SQLVAR        SQL_VAR(i)
     C                   EXSR      DetFldLen
     C                   EVAL      RunPtr=RunPtr+FldByt
     C                   EVAL      RunInd=RunInd+2
     C                   ENDFOR
     C                   ENDSR

     C*------------------
     C* DETERMINE FIELD LENGHT
     C*------------------
     C     DetFldLen     BEGSR
     C*                  EVAL      FldNam=%XLATE(X'20':x'00':FldNam)
     C                   EVAL      FldSca=0
     C                   SELECT
     C                   WHEN      SQLTYPE=384 OR SQLTYPE=385
     C                   EVAL      FldByt=      10
     C                   EVAL      FldLen=       8
     C                   EVAL      FldLen=      10
     C                   WHEN      SQLTYPE=388 OR SQLTYPE=389
     C                   EVAL      FldByt=       8
     C                   EVAL      FldLen=       8
     C                   WHEN      SQLTYPE=392 OR SQLTYPE=393
     C                   EVAL      FldByt=      26
     C                   EVAL      FldLen=      26
     C                   WHEN      SQLTYPE=396 OR SQLTYPE=397
     C                   EVAL      FldByt=       SQLLEN
     C                   EVAL      FldLen=       SQLLEN
     C*                  //CHAR
     C                   WHEN      SQLTYPE=452 OR SQLTYPE=453
     C                   EVAL      FldByt=       SQLLEN
     C                   EVAL      FldLen=       SQLLEN
     C                   WHEN      SQLTYPE=455 OR SQLTYPE=456
     C                   EVAL      FldByt=       SQLLEN
     C                   EVAL      FldLen=       SQLLEN
     C                   WHEN      SQLTYPE=464 OR SQLTYPE=465
     C                   EVAL      FldByt=       SQLLEN
     C                   EVAL      FldLen=       SQLLEN
     C                   WHEN      SQLTYPE=468 OR SQLTYPE=469
     C                   EVAL      FldByt=       SQLLEN
     C                   EVAL      FldLen=       SQLLEN
     C                   WHEN      SQLTYPE=472 OR SQLTYPE=473
     C                   EVAL      FldByt=       SQLLEN
     C                   EVAL      FldLen=       SQLLEN
     C                   WHEN      SQLTYPE=480
     C                   EVAL      FldByt=       4
     C                   EVAL      FldLen=       SQLLEN
     C                   WHEN      SQLTYPE=481
     C                   EVAL      FldByt=       8
     C                   EVAL      FldLen=       SQLLEN
     C*                  //PACKED
     C                   WHEN      SQLTYPE=484 OR SQLTYPE=485
     C                   EVAL      FldByt= %INTH(((SQLLEN/256)+ 1)/2)
     C                   EVAL      FldLen= %INT(SQLLEN/256) + 2
     C                   EVAL      FldSca= %REM(SQLLEN:256)
     C                   IF        %SUBST(SQLNAME:1:5)='@INT@'
     C                   EVAL      FldNam=%SUBST(SQLNAME:6:10)
     C                   EVAL      FldNam=%XLATE(X'20':x'00':FldNam)
     C                   EVAL      FldLen= %INT(SQLLEN/256)
     C                   EVAL      FldSca= 0
     C                   ENDIF
     C*                  //ZONED
     C                   WHEN      SQLTYPE=488 OR SQLTYPE=489
     C                   EVAL      FldByt= %INTH(((SQLLEN/256)+ 1)  )-1
     C                   EVAL      FldLen= %INT(SQLLEN/256) + 2
     C                   EVAL      FldSca= %REM(SQLLEN:256)
     C                   IF        %SUBST(SQLNAME:1:5)='@INT@'
     C                   EVAL      FldNam=%SUBST(SQLNAME:6:10)
     C                   EVAL      FldNam=%XLATE(X'20':x'00':FldNam)
     C                   EVAL      FldLen= %INT(SQLLEN/256)
     C                   EVAL      FldSca= 0
     C                   ENDIF
     C                   WHEN      SQLTYPE=496 OR SQLTYPE=497
     C                   EVAL      FldByt=       4
     C                   WHEN      SQLTYPE=500 OR SQLTYPE=501
     C                   EVAL      FldByt=       2
     C                   ENDSL
     C                   IF        %SUBST(SQLNAME:1:4)='@F8@'
     C                             AND FLDSCA=0 AND FLDLEN=10
     C                   EVAL      FldNam=%SUBST(SQLNAME:5:10)
     C                   EVAL      FldNam=%XLATE(X'20':x'00':FldNam)
     C                   EVAL      FldByt=       8
     C                   EVAL      FldLen=       8
     C                   ENDIF
     C                   IF        %SUBST(SQLNAME:1:4)='@F6@'
     C                             AND FLDSCA=0 AND FLDLEN=8
     C                   EVAL      FldNam=%SUBST(SQLNAME:5:10)
     C                   EVAL      FldNam=%XLATE(X'20':x'00':FldNam)
     C                   EVAL      FldByt=       6
     C                   EVAL      FldLen=       8
     C                   ENDIF
     c                   If        FldLen < %Len(%Trim(SQLNAME))
     c                   Eval      FldLen = %Len(%Trim(SQLNAME))
     C                   EndIf
     C                   ENDSR

     P sysSndPgmMsg    B                   EXPORT
     D  sysSndPgmMsg   PI             4A
     D   msgID                        7A   CONST
     D   msgF                        20A   CONST OPTIONS(*NOPASS)
     D   msgDta                     256A   CONST OPTIONS(*NOPASS)
     D   msgTyp                      10A   CONST OPTIONS(*NOPASS)

     D MSGKEY          S              4A

     D Sndpm           PR                  ExtPgm('QMHSNDPM')
     D   MessageID                    7A   Const
     D   QualMsgF                    20A   Const
     D   MsgData                    256A   Const
     D   MsgDtaLen                   10I 0 Const
     D   MsgType                     10A   Const
     D   CallStkEnt                  10A   Const
     D   CallStkCnt                  10I 0 Const
     D   MessageKey                   4A
     D   ErrorCode                32766A   options(*varsize)


     D wwMsgLen        S             10I 0
     D wwMsgF          S             20A
     D wwMsgD          S            256A
     D wwTheKey        S              4A
     D wwMsgTyp        S             10A   INZ('*ESCAPE')

     c                   eval      wwMsgF='QCPFMSG   *LIBL     '
     c                   eval      wwMsgD=*BLANKS
     C                   if        %parms  >= 2
     c                   eval      wwMsgF=msgF
     c                   endif
     C                   if        %parms  >= 3
     c                   eval      wwMsgD=msgDta
     c                   endif
     C                   if        %parms  >= 4
     c                   eval      wwMsgTyp=msgTyp
     c                   endif
     c                   eval      wwMsgLen = %len(%trimr(wwMsgD))
     c                   callp     SndPm(msgID :wwMsgF     :
     c                                   wwMsgD: wwMsgLen: wwMsgTyp   :
     c                                   '*CTLBDY': 1: wwTheKey: SYSERR)

     C                   RETURN    wwTheKey

     P sysSndPgmMsg    E
